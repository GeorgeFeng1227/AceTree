package org.rhwlab.image.ParsingLogic;

public class ImageNameLogic {

    /**
     * @author Braden Katzman
     *
     * Part of the configuration and image loading revisions from 10/2018
     *
     * Update the image path from the 8bit one listed in the .xml file
     * to a 16bit one. This is used in the case of 8bit images not existing,
     * or explicit need to use 16bit images in the presence of both types
     *
     * The directory structure that this expects when doing this conversion looks like this
     * ...someDir/
     *      image/
     *          tif/
     *              8bit_image_t#_p#.tif
     *      16bit_image_t#.TIF
     *
     * That is, the expected convention is that the 8bit images generated by StarryNite are stored 2 subdirectories deeper in the
     * dataset directory from the 16bit images. Specifically, those directories are image/ and tif/. This method will only find
     * 16bit images if the 8bit images are stored in directories named exactly as such, and the 16bit .TIF shares the same file
     * prefix as the 8bit, and sits next to the image directory/
     *
     * Note that if 8bit files no longer exist in the image/tif/ directory, an xml file with a properly configured 8bit image name
     * will work because the method will pull the path preceding the name, and then extract the prefix of the name from the time and
     * plane identifiers to find the 16bit corollary.
     *
     * If your situation differs from this convention, convert your directory structure to match this, or alternatively, modify this
     * method and/or add a method alongside it that meets your demands.
     * @return the updated file path or the original path if a failure occurs
     * (Note, the calling class should check if the update was successful, and if so, set the useStack flag to indicate that 16bit images are present)
     */
    public static String reconfigureImagePathFrom8bitTo16bit(String _8bitImagePath) {
        System.out.println("Reconfiguring image path for an 8bit image to a 16bit TIF, if possible. ImageNameLogic.reconfigureImagePathFrom8BithTo16Bit()");

        //try using layered images two directories up
        int fileNameIdx = _8bitImagePath.lastIndexOf('/');

        // find the name of the file i.e. cut off everything having to do with either an absolute or relative path in the string passed
        String fileName;
        if (fileNameIdx > 0) {
            fileName = _8bitImagePath.substring(fileNameIdx+1);
        } else {
            System.out.println("Couldn't access filename (i.e. substring after last '/') when trying to convert 8bit image name to 16bit. Returning 8bit image filename.");
            return _8bitImagePath;
        }

        // if this is an 8bit image, it is a slice and should have an identitier for the plane number. Let's look for it
        int planeIdx = fileName.indexOf("-p");

        String fileNameNoPlane;
        if (planeIdx > 0) {
            fileNameNoPlane = fileName.substring(0, planeIdx - 1);
        } else {
            System.out.println("Couldn't locate a plane ID in the filename (i.e. 'p#'). This is needed to extract the shared prefix " +
                    "between 8bit and 16bit images in the convention expected. Returning 8bit image filename");
            return _8bitImagePath;
        }

        int extIdx = fileName.lastIndexOf('.');
        String ext;
        if (extIdx > 0) {
            ext = fileName.substring(extIdx).toUpperCase();
        } else {
            System.out.println("No extension in filename. Returning 8bit image filename");
            return _8bitImagePath;
        }


        int lastDashIdx = fileNameNoPlane.lastIndexOf('-');
        String filePrefix;
        if (lastDashIdx > 0) {
           filePrefix = fileNameNoPlane.substring(0, lastDashIdx) + '_';
        } else {
            System.out.println("No dash in file name separating shared prefix with 16bit images with 8bit specific naming conventions. Returning 8bit image filename");
            return _8bitImagePath;
        }


        int tIdx = fileName.indexOf("-t");
        if (tIdx > 0) {
            if (fileName.charAt(tIdx+2) == '0') {
                tIdx+=2;

                while(fileName.charAt(tIdx) == '0') {
                    tIdx++;
                }
            }
        } else {
            System.out.println("No time ID '-t' in filename which is necessary to extract the filename prefix. Returning 8bit image filename");
            return _8bitImagePath;
        }

        String t = 't' + fileName.substring(tIdx, planeIdx);

        String fileNameUpdate = filePrefix + t + ext;

        int removeDirsIdx = _8bitImagePath.indexOf("image/tif");
        if (removeDirsIdx > 0) {
            String filePre = _8bitImagePath.substring(0, removeDirsIdx);

            String finalPath = filePre + fileNameUpdate;
            return finalPath;
        } else {
            System.out.println("8bit image is not contained in .../image/tif/ subdirectory so 16bit image couldn't be located. Returning 8bit image filename");
            return _8bitImagePath;
        }
    }

    /**
     * This is only a semi-reliable way of determining an image type. Use it cautiously
     * @param imageName
     * @return
     */
    public static boolean is8bitImage(String imageName) {
        if (imageName.toLowerCase().contains("-p")) {
            return true;
        }

        return false;
    }

//    public static void main(String[] args) {
//        String test = "/media/braden/24344443-dff2-4bf4-b2c6-b8c551978b83/AceTree_data/data_post2018/09082016_lineage/image/tif/KB_BV395_09082016_1_s1-t001-p01.tif";
//        String updatedStr = reconfigureImagePathFrom8bitTo16bit(test);
//        System.out.println(updatedStr);
//    }
}
