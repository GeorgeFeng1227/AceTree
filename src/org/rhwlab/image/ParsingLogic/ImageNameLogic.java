package org.rhwlab.image.ParsingLogic;

import java.io.File;

public class ImageNameLogic {

    private static String DASH = "-";
    private static String UNDERSCORE = "_";
    private static String COLOR = "Color";
    private static String SPIM = "SPIM";

    /**
     * @author Braden Katzman
     *
     * Part of the configuration and image loading revisions from 10/2018
     *
     * Update the image path from the 8bit one listed in the .xml file
     * to a 16bit one. This is used in the case of 8bit images not existing,
     * or explicit need to use 16bit images in the presence of both types
     *
     * The directory structure that this expects when doing this conversion looks like this
     * ...someDir/
     *      image/
     *          tif/
     *              8bit_image_t#_p#.tif
     *      16bit_image_t#.TIF
     *
     * That is, the expected convention is that the 8bit images generated by StarryNite are stored 2 subdirectories deeper in the
     * dataset directory from the 16bit images. Specifically, those directories are image/ and tif/. This method will only find
     * 16bit images if the 8bit images are stored in directories named exactly as such, and the 16bit .TIF shares the same file
     * prefix as the 8bit, and sits next to the image directory/
     *
     * Note that if 8bit files no longer exist in the image/tif/ directory, an xml file with a properly configured 8bit image name
     * will work because the method will pull the path preceding the name, and then extract the prefix of the name from the time and
     * plane identifiers to find the 16bit corollary.
     *
     * If your situation differs from this convention, convert your directory structure to match this, or alternatively, modify this
     * method and/or add a method alongside it that meets your demands.
     * @return the updated file path or the original path if a failure occurs
     * (Note, the calling class should check if the update was successful, and if so, set the useStack flag to indicate that 16bit images are present)
     */
    public static String reconfigureImagePathFrom8bitTo16bit(String _8bitImagePath) {
        System.out.println("Reconfiguring image path for an 8bit image to a 16bit TIF, if possible. ImageNameLogic.reconfigureImagePathFrom8BithTo16Bit()");

        //try using layered images two directories up
        int fileNameIdx = _8bitImagePath.lastIndexOf('/');

        // find the name of the file i.e. cut off everything having to do with either an absolute or relative path in the string passed
        String fileName;
        if (fileNameIdx > 0) {
            fileName = _8bitImagePath.substring(fileNameIdx+1);
        } else {
            System.out.println("Couldn't access filename (i.e. substring after last '/') when trying to convert 8bit image name to 16bit. Returning 8bit image filename.");
            return _8bitImagePath;
        }

        // if this is an 8bit image, it is a slice and should have an identitier for the plane number. Let's look for it
        int planeIdx = fileName.indexOf("-p");

        String fileNameNoPlane;
        if (planeIdx > 0) {
            fileNameNoPlane = fileName.substring(0, planeIdx - 1);
        } else {
            System.out.println("Couldn't locate a plane ID in the filename (i.e. 'p#'). This is needed to extract the shared prefix " +
                    "between 8bit and 16bit images in the convention expected. Returning 8bit image filename");
            return _8bitImagePath;
        }

        int extIdx = fileName.lastIndexOf('.');
        String ext;
        if (extIdx > 0) {
            ext = fileName.substring(extIdx).toUpperCase();
        } else {
            System.out.println("No extension in filename. Returning 8bit image filename");
            return _8bitImagePath;
        }


        int lastDashIdx = fileNameNoPlane.lastIndexOf('-');
        String filePrefix;
        if (lastDashIdx > 0) {
           filePrefix = fileNameNoPlane.substring(0, lastDashIdx) + '_';
        } else {
            System.out.println("No dash in file name separating shared prefix with 16bit images with 8bit specific naming conventions. Returning 8bit image filename");
            return _8bitImagePath;
        }


        int tIdx = fileName.indexOf("-t");
        if (tIdx > 0) {
            if (fileName.charAt(tIdx+2) == '0') {
                tIdx+=2;

                while(fileName.charAt(tIdx) == '0') {
                    tIdx++;
                }
            }
        } else {
            System.out.println("No time ID '-t' in filename which is necessary to extract the filename prefix. Returning 8bit image filename");
            return _8bitImagePath;
        }

        String t = 't' + fileName.substring(tIdx, planeIdx);

        String fileNameUpdate = filePrefix + t + ext;

        int removeDirsIdx = _8bitImagePath.indexOf("image/tif");
        if (removeDirsIdx > 0) {
            String filePre = _8bitImagePath.substring(0, removeDirsIdx);

            String finalPath = filePre + fileNameUpdate;
            return finalPath;
        } else {
            System.out.println("8bit image is not contained in .../image/tif/ subdirectory so 16bit image couldn't be located. Returning 8bit image filename");
            return _8bitImagePath;
        }
    }

    /**
     * Method to locate the second color channel of an iSIM dataset given the location of one color. This
     * method expects the image files follow the native iSIM output format, which lists all image stacks
     * in a single directory, with their filenames distinguishing between the two color channels. In short,
     * this method parses the tokens of the given filename, identifies it's color, and then looks for a
     * corresponding image stack with a different color channel token.
     *
     * Example:
     * iSIM_image_directory/
     *      researcherInitials_datasetIdentifier_w1iSIM - FITC - ###-##_s#_t#.TIF
     *      researcherInitials_datasetIdentifier_w2iSIM - TxRed - ###-##_s#_t#.TIF
     *
     *
     * @param iSIM_image_filename
     * @return
     */
    public static String findSecondiSIMColorChannel(String iSIM_image_filename) {
        //if (iSIM_image_filename == null || iSIM_image_filename.isEmpty() || !new File(iSIM_image_filename).exists()) {
        if (iSIM_image_filename == null || iSIM_image_filename.isEmpty()) {
            System.out.println("Can't locate second color channel in iSIM dataset. Invalid image file given.");
            return "";
        }

        // extract the prefix before the w# identifier
        int _wIdx = iSIM_image_filename.indexOf("_w");
        if (_wIdx == -1) {
            System.out.println("Couldn't extract channel identifier from iSIM image file name");
            return "";
        }

        String prefix = iSIM_image_filename.substring(0, _wIdx);
        char channelNumberIDChar = iSIM_image_filename.charAt(_wIdx+2);

        // make sure the channel number ID is a digit
        if (!Character.isDigit(channelNumberIDChar)) {
            System.out.println("Couldn't extract channel identifier number from iSIM image file name");
            return "";
        }

        int channelNumberID = Character.getNumericValue(channelNumberIDChar);



        return "";


    }

    /**
     * Method to locate the second channel of an diSPIM dataset given the location of one color. This
     * method expects the image files and directories follow the native diSPIM output formats, either
     * fused or single view stacks.
     *
     * Example (fused):
     * diSPIM (fused)
     *       Color1/
     *           Decon/
     *               Decon_#.tif
     *       Color2/
     *           Decon/
     *               Decon_#.tif
     *
     *
     * Example (single views):
     * diSPIM_singleviews/
     *       SPIMA/
     *           ### nm/ the numbers here correspond the the length of the wavelength of light used by the scope (which corresponds to the excitation range of the fluorophore targeted)
     *               SPIMA-#.tif
     *           ### nm/
     *               SPIMA-#.tif (names match that of other directory ^^^)
     *       SPIMB/
     *           ### nm/
     *               SPIMB-#.tif
     *           ### nm/ (note - 2 subfolders have matching name in SPIMA, SPIMB)
     *               SPIMB-#.tif (names match that of other directory ^^^)
     *
     *  *Note: if an image in SPIMA/ is provided, it will return it's counterpart also in SPIMA/. AceTree does
     *  not currently support fusing multiple views
     *
     * @param diSPIM_image_filename
     * @return
     */
    public static String findSecondDiSPIMColorChannel(String diSPIM_image_filename) {
        // figure out if this is a fused image (i.e both views fused) or a single view image
        if (diSPIM_image_filename.contains(COLOR)) {
            System.out.println("Locating second channel for diSPIM fused images");
            // figure out if the image file is in the Color1 or Color2 directory
            char colorNumber = diSPIM_image_filename.charAt(diSPIM_image_filename.indexOf(COLOR) + COLOR.length());

            char colorNumberSwap = '0';
            if (colorNumber == '1') {
                colorNumberSwap = '2';
            } else if (colorNumber == '2') {
                colorNumberSwap = '1';
            } else {
                System.out.println("Color#/ directory containing diSPIM image needs to be either 1 or 2.");
                return "";
            }

            // swap the colors
            return diSPIM_image_filename.substring(0, diSPIM_image_filename.indexOf(COLOR) + COLOR.length())
                    + colorNumberSwap
                    + diSPIM_image_filename.substring(diSPIM_image_filename.indexOf(COLOR) + COLOR.length() + 1);
        } else if (diSPIM_image_filename.contains(SPIM)) {
            System.out.println("Locating second channel for diSPIM single view images (just using one scope view)");
        } else {
            System.out.println("diSPIM image file path doesn't contain 'Color' (fused views) or 'SPIM' (single views) so directory structure can't be inferred");
            return "";
        }

        return "";
    }

    /**
     * This is only a semi-reliable way of determining an image type. Use it cautiously
     * @param imageName
     * @return
     */
    public static boolean is8bitImage(String imageName) {
        if (imageName.toLowerCase().contains("-p")) {
            return true;
        }

        return false;
    }

    public static void main(String[] args) {
//        String test = "/media/braden/24344443-dff2-4bf4-b2c6-b8c551978b83/AceTree_data/data_post2018/09082016_lineage/image/tif/KB_BV395_09082016_1_s1-t001-p01.tif";
//        String updatedStr = reconfigureImagePathFrom8bitTo16bit(test);
//        System.out.println(updatedStr);

        //String test = "/media/braden/24344443-dff2-4bf4-b2c6-b8c551978b83/AceTree_data/data_post2018/09082016_lineage/researcherInitials_datasetIdentifier_w1iSIM - FITC - ###-##_s#_t#.TIF";
        //findSecondiSIMColorChannel(test);

        String test1 = "/media/braden/24344443-dff2-4bf4-b2c6-b8c551978b83/AceTree_data/data_post2018/09082016_lineage/Color1/Decon/Decon_1.TIF";
        String result = findSecondDiSPIMColorChannel(test1);
        System.out.println(result);

    }
}
